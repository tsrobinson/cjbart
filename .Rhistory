subjects$vacc_p_final > 1 ~ 1,
TRUE ~ subjects$vacc_p_final)
subjects$vaccinated <- rbinom(nrow(subjects), size = 1, prob = subjects$vacc_p_final)
# Regression model
return(tidy(summary(lm(vaccinated ~ t_arm, data = subjects))))
}
power_calc <- function(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere) {
out_results <- lapply(1:B, function (b) {
exp <- simulate_experiment(d, v_d, v_n, taus, multi_p, single_p, multi_interfere)
exp$B <- b
return(exp)
}) %>%
do.call("rbind", .)
out_results %>%
mutate(sig = ifelse(p.value < 0.05, 1,0)) %>%
group_by(term) %>%
summarise(est_avg = mean(estimate),
power = mean(sig)) %>%
return(.)
}
# Simulate without any interference
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = FALSE)
# Simulate without any interference
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = TRUE)
simulate_experiment <- function(d, v_d, v_n, taus, multi_p, single_p, multi_interfere) {
# Set parameters
n_subjects = d*v_d*v_n
placebo_p = 1 - multi_p - single_p
treatments = c("CDC","low_cash","high_cash")
tau_table <- data.frame(
t_arm = c("placebo", treatments),
tau = c(0, taus)
)
# Build village-level data
villages <- data.frame(
v_id = 1:(d*v_d),
d_id = rep(1:d, each = v_d),
v_fe = rnorm(n=v_d, mean = 0, sd = 0.02),
v_treat = do.call(
"c",
lapply(
1:d,
function (x) {
sample(rep(c("multi","single","placebo"),
times = c(v_d*multi_p, v_d*single_p, v_d*placebo_p),
size = v_d, replace = FALSE))
}
)
)
)
villages$t_arm <- NA
villages$t_arm[villages$v_treat == "placebo"] <- "placebo"
villages$t_arm[villages$v_treat == "single"] <- sample(treatments,
size = sum(villages$v_treat == "single"),
replace = TRUE)
subjects <- data.frame(id = 1:(d*v_d*v_n),
v_id = rep(1:(v_d*d), each = v_n)) %>%
left_join(villages, by = "v_id")
subjects$t_arm[subjects$v_treat == "multi"] <- sample(treatments,
size = sum(subjects$v_treat == "multi"),
replace = TRUE)
# Build subject-level data
subjects <- subjects %>%
left_join(tau_table, by = "t_arm") %>%
mutate(vacc_p = tau + v_fe + rnorm(n_subjects, mean = 0.1, sd = 0.05),
t_arm = relevel(as.factor(t_arm), ref = "placebo"))
# Apply interference in multiply-treated villages
if (multi_interfere) {
subjects <- mutate(subjects,
vacc_p_final = vacc_p - case_when(v_treat == "multi" & t_arm == "CDC" ~ 0.02,
v_treat == "multi" & t_arm == "low_cash" ~ 0.01,
TRUE ~ 0)
)
} else {
subjects <- mutate(subjects,
vacc_p_final = vacc_p)
}
subjects$vacc_p_final <- case_when(subjects$vacc_p_final < 0 ~ 0,
subjects$vacc_p_final > 1 ~ 1,
TRUE ~ subjects$vacc_p_final)
subjects$vaccinated <- rbinom(nrow(subjects), size = 1, prob = subjects$vacc_p_final)
# Regression model
return(tidy(summary(lm(vaccinated ~ t_arm, data = subjects))))
}
# Simulate without any interference
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = TRUE)
library(tidyverse)
library(broom)
set.seed(89)
d = 6
v_d = 50
v_n = 21
multi_interfere = FALSE
taus = c(0.02, 0.04, 0.06) # relative to placebo
multi_p = 0.6
single_p = 0.2
simulate_experiment <- function(d, v_d, v_n, taus, multi_p, single_p, multi_interfere) {
# Set parameters
n_subjects = d*v_d*v_n
placebo_p = 1 - multi_p - single_p
treatments = c("CDC","low_cash","high_cash")
tau_table <- data.frame(
t_arm = c("placebo", treatments),
tau = c(0, taus)
)
# Build village-level data
villages <- data.frame(
v_id = 1:(d*v_d),
d_id = rep(1:d, each = v_d),
v_fe = rnorm(n=v_d, mean = 0, sd = 0.02),
v_treat = do.call(
"c",
lapply(
1:d,
function (x) {
sample(rep(c("multi","single","placebo"),
times = c(v_d*multi_p, v_d*single_p, v_d*placebo_p),
size = v_d, replace = FALSE))
}
)
)
)
villages$t_arm <- NA
villages$t_arm[villages$v_treat == "placebo"] <- "placebo"
villages$t_arm[villages$v_treat == "single"] <- sample(treatments,
size = sum(villages$v_treat == "single"),
replace = TRUE)
subjects <- data.frame(id = 1:(d*v_d*v_n),
v_id = rep(1:(v_d*d), each = v_n)) %>%
left_join(villages, by = "v_id")
subjects$t_arm[subjects$v_treat == "multi"] <- sample(treatments,
size = sum(subjects$v_treat == "multi"),
replace = TRUE)
# Build subject-level data
subjects <- subjects %>%
left_join(tau_table, by = "t_arm") %>%
mutate(vacc_p = tau + v_fe + rnorm(n_subjects, mean = 0.1, sd = 0.05),
t_arm = relevel(as.factor(t_arm), ref = "placebo"))
# Apply interference in multiply-treated villages
if (multi_interfere) {
subjects <- mutate(subjects,
vacc_p_final = vacc_p - case_when(v_treat == "multi" & t_arm == "CDC" ~ 0.01,
v_treat == "multi" & t_arm == "low_cash" ~ 0.005,
TRUE ~ 0)
)
} else {
subjects <- mutate(subjects,
vacc_p_final = vacc_p)
}
subjects$vacc_p_final <- case_when(subjects$vacc_p_final < 0 ~ 0,
subjects$vacc_p_final > 1 ~ 1,
TRUE ~ subjects$vacc_p_final)
subjects$vaccinated <- rbinom(nrow(subjects), size = 1, prob = subjects$vacc_p_final)
# Regression model
return(tidy(summary(lm(vaccinated ~ t_arm, data = subjects))))
}
power_calc <- function(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere) {
out_results <- lapply(1:B, function (b) {
exp <- simulate_experiment(d, v_d, v_n, taus, multi_p, single_p, multi_interfere)
exp$B <- b
return(exp)
}) %>%
do.call("rbind", .)
out_results %>%
mutate(sig = ifelse(p.value < 0.05, 1,0)) %>%
group_by(term) %>%
summarise(est_avg = mean(estimate),
power = mean(sig)) %>%
return(.)
}
# Simulate without any interference
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = FALSE)
# Simulate without any interference
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = TRUE)
treatments
c("(Intercept)", paste0("t_arm", c("CDC","low_cash","high_cash")))
# Simulate without any interference + ADD VILLAGE FE
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = FALSE, incl_fe = TRUE)
library(tidyverse)
library(broom)
set.seed(89)
d = 6
v_d = 50
v_n = 21
multi_interfere = FALSE
taus = c(0.02, 0.04, 0.06) # relative to placebo
multi_p = 0.6
single_p = 0.2
simulate_experiment <- function(d, v_d, v_n, taus, multi_p, single_p, multi_interfere, incl_fe) {
# Set parameters
n_subjects = d*v_d*v_n
placebo_p = 1 - multi_p - single_p
treatments = c("CDC","low_cash","high_cash")
tau_table <- data.frame(
t_arm = c("placebo", treatments),
tau = c(0, taus)
)
# Build village-level data
villages <- data.frame(
v_id = 1:(d*v_d),
d_id = rep(1:d, each = v_d),
v_fe = rnorm(n=v_d, mean = 0, sd = 0.02),
v_treat = do.call(
"c",
lapply(
1:d,
function (x) {
sample(rep(c("multi","single","placebo"),
times = c(v_d*multi_p, v_d*single_p, v_d*placebo_p),
size = v_d, replace = FALSE))
}
)
)
)
villages$t_arm <- NA
villages$t_arm[villages$v_treat == "placebo"] <- "placebo"
villages$t_arm[villages$v_treat == "single"] <- sample(treatments,
size = sum(villages$v_treat == "single"),
replace = TRUE)
subjects <- data.frame(id = 1:(d*v_d*v_n),
v_id = rep(1:(v_d*d), each = v_n)) %>%
left_join(villages, by = "v_id")
subjects$t_arm[subjects$v_treat == "multi"] <- sample(treatments,
size = sum(subjects$v_treat == "multi"),
replace = TRUE)
# Build subject-level data
subjects <- subjects %>%
left_join(tau_table, by = "t_arm") %>%
mutate(vacc_p = tau + v_fe + rnorm(n_subjects, mean = 0.1, sd = 0.05),
t_arm = relevel(as.factor(t_arm), ref = "placebo"))
# Apply interference in multiply-treated villages
if (multi_interfere) {
subjects <- mutate(subjects,
vacc_p_final = vacc_p - case_when(v_treat == "multi" & t_arm == "CDC" ~ 0.01,
v_treat == "multi" & t_arm == "low_cash" ~ 0.005,
TRUE ~ 0)
)
} else {
subjects <- mutate(subjects,
vacc_p_final = vacc_p)
}
subjects$vacc_p_final <- case_when(subjects$vacc_p_final < 0 ~ 0,
subjects$vacc_p_final > 1 ~ 1,
TRUE ~ subjects$vacc_p_final)
subjects$vaccinated <- rbinom(nrow(subjects), size = 1, prob = subjects$vacc_p_final)
# Regression model
if (incl_fe) {
tidy(summary(lm(vaccinated ~ t_arm, data = subjects))) %>%
filter(term %in% c("(Intercept)", paste0("t_arm", treatments))) %>%
return(.)
} else {
return(tidy(summary(lm(vaccinated ~ t_arm, data = subjects))))
}
}
power_calc <- function(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere) {
out_results <- lapply(1:B, function (b) {
exp <- simulate_experiment(d, v_d, v_n, taus, multi_p, single_p, multi_interfere)
exp$B <- b
return(exp)
}) %>%
do.call("rbind", .)
out_results %>%
mutate(sig = ifelse(p.value < 0.05, 1,0)) %>%
group_by(term) %>%
summarise(est_avg = mean(estimate),
power = mean(sig)) %>%
return(.)
}
# Simulate without any interference
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = FALSE, incl_fe = FALSE)
# Simulate without any interference + ADD VILLAGE FE
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = FALSE, incl_fe = TRUE)
library(tidyverse)
library(broom)
set.seed(89)
d = 6
v_d = 50
v_n = 21
multi_interfere = FALSE
taus = c(0.02, 0.04, 0.06) # relative to placebo
multi_p = 0.6
single_p = 0.2
simulate_experiment <- function(d, v_d, v_n, taus, multi_p, single_p, multi_interfere, incl_fe) {
# Set parameters
n_subjects = d*v_d*v_n
placebo_p = 1 - multi_p - single_p
treatments = c("CDC","low_cash","high_cash")
tau_table <- data.frame(
t_arm = c("placebo", treatments),
tau = c(0, taus)
)
# Build village-level data
villages <- data.frame(
v_id = 1:(d*v_d),
d_id = rep(1:d, each = v_d),
v_fe = rnorm(n=v_d, mean = 0, sd = 0.02),
v_treat = do.call(
"c",
lapply(
1:d,
function (x) {
sample(rep(c("multi","single","placebo"),
times = c(v_d*multi_p, v_d*single_p, v_d*placebo_p),
size = v_d, replace = FALSE))
}
)
)
)
villages$t_arm <- NA
villages$t_arm[villages$v_treat == "placebo"] <- "placebo"
villages$t_arm[villages$v_treat == "single"] <- sample(treatments,
size = sum(villages$v_treat == "single"),
replace = TRUE)
subjects <- data.frame(id = 1:(d*v_d*v_n),
v_id = rep(1:(v_d*d), each = v_n)) %>%
left_join(villages, by = "v_id")
subjects$t_arm[subjects$v_treat == "multi"] <- sample(treatments,
size = sum(subjects$v_treat == "multi"),
replace = TRUE)
# Build subject-level data
subjects <- subjects %>%
left_join(tau_table, by = "t_arm") %>%
mutate(vacc_p = tau + v_fe + rnorm(n_subjects, mean = 0.1, sd = 0.05),
t_arm = relevel(as.factor(t_arm), ref = "placebo"))
# Apply interference in multiply-treated villages
if (multi_interfere) {
subjects <- mutate(subjects,
vacc_p_final = vacc_p - case_when(v_treat == "multi" & t_arm == "CDC" ~ 0.01,
v_treat == "multi" & t_arm == "low_cash" ~ 0.005,
TRUE ~ 0)
)
} else {
subjects <- mutate(subjects,
vacc_p_final = vacc_p)
}
subjects$vacc_p_final <- case_when(subjects$vacc_p_final < 0 ~ 0,
subjects$vacc_p_final > 1 ~ 1,
TRUE ~ subjects$vacc_p_final)
subjects$vaccinated <- rbinom(nrow(subjects), size = 1, prob = subjects$vacc_p_final)
# Regression model
if (incl_fe) {
tidy(summary(lm(vaccinated ~ t_arm, data = subjects))) %>%
filter(term %in% c("(Intercept)", paste0("t_arm", treatments))) %>%
return(.)
} else {
return(tidy(summary(lm(vaccinated ~ t_arm, data = subjects))))
}
}
power_calc <- function(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere, incl_fe) {
out_results <- lapply(1:B, function (b) {
exp <- simulate_experiment(d, v_d, v_n, taus, multi_p, single_p, multi_interfere)
exp$B <- b
return(exp)
}) %>%
do.call("rbind", .)
out_results %>%
mutate(sig = ifelse(p.value < 0.05, 1,0)) %>%
group_by(term) %>%
summarise(est_avg = mean(estimate),
power = mean(sig)) %>%
return(.)
}
# Simulate without any interference
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = FALSE, incl_fe = FALSE)
# Simulate without any interference + ADD VILLAGE FE
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = FALSE, incl_fe = TRUE)
library(tidyverse)
library(broom)
set.seed(89)
d = 6
v_d = 50
v_n = 21
multi_interfere = FALSE
taus = c(0.02, 0.04, 0.06) # relative to placebo
multi_p = 0.6
single_p = 0.2
simulate_experiment <- function(d, v_d, v_n, taus, multi_p, single_p, multi_interfere, incl_fe) {
# Set parameters
n_subjects = d*v_d*v_n
placebo_p = 1 - multi_p - single_p
treatments = c("CDC","low_cash","high_cash")
tau_table <- data.frame(
t_arm = c("placebo", treatments),
tau = c(0, taus)
)
# Build village-level data
villages <- data.frame(
v_id = 1:(d*v_d),
d_id = rep(1:d, each = v_d),
v_fe = rnorm(n=v_d, mean = 0, sd = 0.02),
v_treat = do.call(
"c",
lapply(
1:d,
function (x) {
sample(rep(c("multi","single","placebo"),
times = c(v_d*multi_p, v_d*single_p, v_d*placebo_p),
size = v_d, replace = FALSE))
}
)
)
)
villages$t_arm <- NA
villages$t_arm[villages$v_treat == "placebo"] <- "placebo"
villages$t_arm[villages$v_treat == "single"] <- sample(treatments,
size = sum(villages$v_treat == "single"),
replace = TRUE)
subjects <- data.frame(id = 1:(d*v_d*v_n),
v_id = rep(1:(v_d*d), each = v_n)) %>%
left_join(villages, by = "v_id")
subjects$t_arm[subjects$v_treat == "multi"] <- sample(treatments,
size = sum(subjects$v_treat == "multi"),
replace = TRUE)
# Build subject-level data
subjects <- subjects %>%
left_join(tau_table, by = "t_arm") %>%
mutate(vacc_p = tau + v_fe + rnorm(n_subjects, mean = 0.1, sd = 0.05),
t_arm = relevel(as.factor(t_arm), ref = "placebo"))
# Apply interference in multiply-treated villages
if (multi_interfere) {
subjects <- mutate(subjects,
vacc_p_final = vacc_p - case_when(v_treat == "multi" & t_arm == "CDC" ~ 0.01,
v_treat == "multi" & t_arm == "low_cash" ~ 0.005,
TRUE ~ 0)
)
} else {
subjects <- mutate(subjects,
vacc_p_final = vacc_p)
}
subjects$vacc_p_final <- case_when(subjects$vacc_p_final < 0 ~ 0,
subjects$vacc_p_final > 1 ~ 1,
TRUE ~ subjects$vacc_p_final)
subjects$vaccinated <- rbinom(nrow(subjects), size = 1, prob = subjects$vacc_p_final)
# Regression model
if (incl_fe) {
tidy(summary(lm(vaccinated ~ t_arm, data = subjects))) %>%
filter(term %in% c("(Intercept)", paste0("t_arm", treatments))) %>%
return(.)
} else {
return(tidy(summary(lm(vaccinated ~ t_arm, data = subjects))))
}
}
power_calc <- function(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere, incl_fe) {
out_results <- lapply(1:B, function (b) {
exp <- simulate_experiment(d, v_d, v_n, taus, multi_p, single_p, multi_interfere, incl_fe)
exp$B <- b
return(exp)
}) %>%
do.call("rbind", .)
out_results %>%
mutate(sig = ifelse(p.value < 0.05, 1,0)) %>%
group_by(term) %>%
summarise(est_avg = mean(estimate),
power = mean(sig)) %>%
return(.)
}
# Simulate without any interference
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = FALSE, incl_fe = FALSE)
# Simulate without any interference + ADD VILLAGE FE
power_calc(B = 1000, d, v_d, v_n, taus, multi_p, single_p, multi_interfere = FALSE, incl_fe = TRUE)
library(rMIDAS)
library(devtools)
install_github("MIDASverse/rMIDAS")
library(rMIDAS)
rMIDAS()
rMIDAS(...)
?rMIDAS
install.packages("randomForestSRC")
library(randomForestSRC)
data(veteran, packages = "randomForestSRC")
data(veteran, package = "randomForestSRC")
v.obj <- rfsrc(Surv(time, status) ~ ., veteran, ntree = 100)
plot.variable(v.obj, surv.type = "surv", partial = TRUE, smooth.lines = TRUE)
install.packages(c("jmv", "tidyverse", "haven"))
setwd("~/Dropbox/cjbart")
library(devtools)
use_cran_badge()
use_lifecycle_badge("experimental")
use_github_actions()
check()
check()
check()
update.packages("roxygen2")
library(roxygen2)
install.packages("roxygen2")
library(devtools)
check()
check()
check()
check()
check()
check_rhub()
rhub::validate_email()
check_rhub()
check_win_devel()
check_win_release()
install.packages(c("backports", "bayestestR", "BH", "blob", "brew", "brio", "broom", "broom.mixed", "broomExtra", "bslib", "cachem", "car", "carData", "cli", "coin", "colorspace", "colourpicker", "conquer", "corrplot", "cpp11", "crayon", "credentials", "crosstalk", "DBI", "desc", "DescTools", "devtools", "DiagrammeR", "diffobj", "digest", "dotwhisker", "dplyr", "DT", "dtplyr", "e1071", "estimatr", "Exact", "fansi", "fs", "gargle", "generics", "gert", "ggsignif", "gld", "glue", "googledrive", "googlesheets4", "gower", "grf", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "influenceR", "insight", "ipred", "isoband", "jpeg", "keras", "knitr", "later", "lava", "lifecycle", "lme4", "lmtest", "lubridate", "magrittr", "mapproj", "maps", "maptools", "Matching", "MatchIt", "matrixStats", "memoise", "mice", "mime", "multcomp", "mvtnorm", "nloptr", "openssl", "openxlsx", "optmatch", "packrat", "parameters", "performance", "pillar", "pkgbuild", "pkgload", "qualtRics", "quantreg", "R6", "randomForest", "rbibutils", "rcmdcheck", "RcppArmadillo", "RcppParallel", "Rdpack", "readr", "recipes", "remotes", "reprex", "rio", "rlang", "rmarkdown", "rootSolve", "rpart", "rsconnect", "rstan", "rvest", "sessioninfo", "shiny", "shinyjs", "sp", "stringi", "survey", "tensorflow", "testthat", "tibble", "tidyr", "tinytex", "TMB", "usethis", "utf8", "uuid", "V8", "vcd", "viridis", "visNetwork", "waldo", "xfun", "xml2", "yaml"))
install.packages(c("backports", "bayestestR", "BH", "blob", "brew", "brio", "broom", "broom.mixed", "broomExtra", "bslib", "cachem", "car", "carData", "cli", "coin", "colorspace", "colourpicker", "conquer", "corrplot", "cpp11", "crayon", "credentials", "crosstalk", "DBI", "desc", "DescTools", "devtools", "DiagrammeR", "diffobj", "digest", "dotwhisker", "dplyr", "DT", "dtplyr", "e1071", "estimatr", "Exact", "fansi", "fs", "gargle", "generics", "gert", "ggsignif", "gld", "glue", "googledrive", "googlesheets4", "gower", "grf", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "influenceR", "insight", "ipred", "isoband", "jpeg", "keras", "knitr", "later", "lava", "lifecycle", "lme4", "lmtest", "lubridate", "magrittr", "mapproj", "maps", "maptools", "Matching", "MatchIt", "matrixStats", "memoise", "mice", "mime", "multcomp", "mvtnorm", "nloptr", "openssl", "openxlsx", "optmatch", "packrat", "parameters", "performance", "pillar", "pkgbuild", "pkgload", "qualtRics", "quantreg", "R6", "randomForest", "rbibutils", "rcmdcheck", "RcppArmadillo", "RcppParallel", "Rdpack", "readr", "recipes", "remotes", "reprex", "rio", "rlang", "rmarkdown", "rootSolve", "rpart", "rsconnect", "rstan", "rvest", "sessioninfo", "shiny", "shinyjs", "sp", "stringi", "survey", "tensorflow", "testthat", "tibble", "tidyr", "tinytex", "TMB", "usethis", "utf8", "uuid", "V8", "vcd", "viridis", "visNetwork", "waldo", "xfun", "xml2", "yaml"))
install.packages(c("backports", "bayestestR", "BH", "blob", "brew", "brio", "broom", "broom.mixed", "broomExtra", "bslib", "cachem", "car", "carData", "cli", "coin", "colorspace", "colourpicker", "conquer", "corrplot", "cpp11", "crayon", "credentials", "crosstalk", "DBI", "desc", "DescTools", "devtools", "DiagrammeR", "diffobj", "digest", "dotwhisker", "dplyr", "DT", "dtplyr", "e1071", "estimatr", "Exact", "fansi", "fs", "gargle", "generics", "gert", "ggsignif", "gld", "glue", "googledrive", "googlesheets4", "gower", "grf", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "influenceR", "insight", "ipred", "isoband", "jpeg", "keras", "knitr", "later", "lava", "lifecycle", "lme4", "lmtest", "lubridate", "magrittr", "mapproj", "maps", "maptools", "Matching", "MatchIt", "matrixStats", "memoise", "mice", "mime", "multcomp", "mvtnorm", "nloptr", "openssl", "openxlsx", "optmatch", "packrat", "parameters", "performance", "pillar", "pkgbuild", "pkgload", "qualtRics", "quantreg", "R6", "randomForest", "rbibutils", "rcmdcheck", "RcppArmadillo", "RcppParallel", "Rdpack", "readr", "recipes", "remotes", "reprex", "rio", "rlang", "rmarkdown", "rootSolve", "rpart", "rsconnect", "rstan", "rvest", "sessioninfo", "shiny", "shinyjs", "sp", "stringi", "survey", "tensorflow", "testthat", "tibble", "tidyr", "tinytex", "TMB", "usethis", "utf8", "uuid", "V8", "vcd", "viridis", "visNetwork", "waldo", "xfun", "xml2", "yaml"))
install.packages(c("backports", "bayestestR", "BH", "blob", "brew", "brio", "broom", "broom.mixed", "broomExtra", "bslib", "cachem", "car", "carData", "cli", "coin", "colorspace", "colourpicker", "conquer", "corrplot", "cpp11", "crayon", "credentials", "crosstalk", "DBI", "desc", "DescTools", "devtools", "DiagrammeR", "diffobj", "digest", "dotwhisker", "dplyr", "DT", "dtplyr", "e1071", "estimatr", "Exact", "fansi", "fs", "gargle", "generics", "gert", "ggsignif", "gld", "glue", "googledrive", "googlesheets4", "gower", "grf", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "influenceR", "insight", "ipred", "isoband", "jpeg", "keras", "knitr", "later", "lava", "lifecycle", "lme4", "lmtest", "lubridate", "magrittr", "mapproj", "maps", "maptools", "Matching", "MatchIt", "matrixStats", "memoise", "mice", "mime", "multcomp", "mvtnorm", "nloptr", "openssl", "openxlsx", "optmatch", "packrat", "parameters", "performance", "pillar", "pkgbuild", "pkgload", "qualtRics", "quantreg", "R6", "randomForest", "rbibutils", "rcmdcheck", "RcppArmadillo", "RcppParallel", "Rdpack", "readr", "recipes", "remotes", "reprex", "rio", "rlang", "rmarkdown", "rootSolve", "rpart", "rsconnect", "rstan", "rvest", "sessioninfo", "shiny", "shinyjs", "sp", "stringi", "survey", "tensorflow", "testthat", "tibble", "tidyr", "tinytex", "TMB", "usethis", "utf8", "uuid", "V8", "vcd", "viridis", "visNetwork", "waldo", "xfun", "xml2", "yaml"))
install.packages(c("backports", "bayestestR", "BH", "blob", "brew", "brio", "broom", "broom.mixed", "broomExtra", "bslib", "cachem", "car", "carData", "cli", "coin", "colorspace", "colourpicker", "conquer", "corrplot", "cpp11", "crayon", "credentials", "crosstalk", "DBI", "desc", "DescTools", "devtools", "DiagrammeR", "diffobj", "digest", "dotwhisker", "dplyr", "DT", "dtplyr", "e1071", "estimatr", "Exact", "fansi", "fs", "gargle", "generics", "gert", "ggsignif", "gld", "glue", "googledrive", "googlesheets4", "gower", "grf", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "influenceR", "insight", "ipred", "isoband", "jpeg", "keras", "knitr", "later", "lava", "lifecycle", "lme4", "lmtest", "lubridate", "magrittr", "mapproj", "maps", "maptools", "Matching", "MatchIt", "matrixStats", "memoise", "mice", "mime", "multcomp", "mvtnorm", "nloptr", "openssl", "openxlsx", "optmatch", "packrat", "parameters", "performance", "pillar", "pkgbuild", "pkgload", "qualtRics", "quantreg", "R6", "randomForest", "rbibutils", "rcmdcheck", "RcppArmadillo", "RcppParallel", "Rdpack", "readr", "recipes", "remotes", "reprex", "rio", "rlang", "rmarkdown", "rootSolve", "rpart", "rsconnect", "rstan", "rvest", "sessioninfo", "shiny", "shinyjs", "sp", "stringi", "survey", "tensorflow", "testthat", "tibble", "tidyr", "tinytex", "TMB", "usethis", "utf8", "uuid", "V8", "vcd", "viridis", "visNetwork", "waldo", "xfun", "xml2", "yaml"))
install.packages(c("backports", "bayestestR", "BH", "blob", "brew", "brio", "broom", "broom.mixed", "broomExtra", "bslib", "cachem", "car", "carData", "cli", "coin", "colorspace", "colourpicker", "conquer", "corrplot", "cpp11", "crayon", "credentials", "crosstalk", "DBI", "desc", "DescTools", "devtools", "DiagrammeR", "diffobj", "digest", "dotwhisker", "dplyr", "DT", "dtplyr", "e1071", "estimatr", "Exact", "fansi", "fs", "gargle", "generics", "gert", "ggsignif", "gld", "glue", "googledrive", "googlesheets4", "gower", "grf", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "influenceR", "insight", "ipred", "isoband", "jpeg", "keras", "knitr", "later", "lava", "lifecycle", "lme4", "lmtest", "lubridate", "magrittr", "mapproj", "maps", "maptools", "Matching", "MatchIt", "matrixStats", "memoise", "mice", "mime", "multcomp", "mvtnorm", "nloptr", "openssl", "openxlsx", "optmatch", "packrat", "parameters", "performance", "pillar", "pkgbuild", "pkgload", "qualtRics", "quantreg", "R6", "randomForest", "rbibutils", "rcmdcheck", "RcppArmadillo", "RcppParallel", "Rdpack", "readr", "recipes", "remotes", "reprex", "rio", "rlang", "rmarkdown", "rootSolve", "rpart", "rsconnect", "rstan", "rvest", "sessioninfo", "shiny", "shinyjs", "sp", "stringi", "survey", "tensorflow", "testthat", "tibble", "tidyr", "tinytex", "TMB", "usethis", "utf8", "uuid", "V8", "vcd", "viridis", "visNetwork", "waldo", "xfun", "xml2", "yaml"))
install.packages(c("backports", "bayestestR", "BH", "blob", "brew", "brio", "broom", "broom.mixed", "broomExtra", "bslib", "cachem", "car", "carData", "cli", "coin", "colorspace", "colourpicker", "conquer", "corrplot", "cpp11", "crayon", "credentials", "crosstalk", "DBI", "desc", "DescTools", "devtools", "DiagrammeR", "diffobj", "digest", "dotwhisker", "dplyr", "DT", "dtplyr", "e1071", "estimatr", "Exact", "fansi", "fs", "gargle", "generics", "gert", "ggsignif", "gld", "glue", "googledrive", "googlesheets4", "gower", "grf", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "influenceR", "insight", "ipred", "isoband", "jpeg", "keras", "knitr", "later", "lava", "lifecycle", "lme4", "lmtest", "lubridate", "magrittr", "mapproj", "maps", "maptools", "Matching", "MatchIt", "matrixStats", "memoise", "mice", "mime", "multcomp", "mvtnorm", "nloptr", "openssl", "openxlsx", "optmatch", "packrat", "parameters", "performance", "pillar", "pkgbuild", "pkgload", "qualtRics", "quantreg", "R6", "randomForest", "rbibutils", "rcmdcheck", "RcppArmadillo", "RcppParallel", "Rdpack", "readr", "recipes", "remotes", "reprex", "rio", "rlang", "rmarkdown", "rootSolve", "rpart", "rsconnect", "rstan", "rvest", "sessioninfo", "shiny", "shinyjs", "sp", "stringi", "survey", "tensorflow", "testthat", "tibble", "tidyr", "tinytex", "TMB", "usethis", "utf8", "uuid", "V8", "vcd", "viridis", "visNetwork", "waldo", "xfun", "xml2", "yaml"))
install.packages(c("backports", "bayestestR", "BH", "blob", "brew", "brio", "broom", "broom.mixed", "broomExtra", "bslib", "cachem", "car", "carData", "cli", "coin", "colorspace", "colourpicker", "conquer", "corrplot", "cpp11", "crayon", "credentials", "crosstalk", "DBI", "desc", "DescTools", "devtools", "DiagrammeR", "diffobj", "digest", "dotwhisker", "dplyr", "DT", "dtplyr", "e1071", "estimatr", "Exact", "fansi", "fs", "gargle", "generics", "gert", "ggsignif", "gld", "glue", "googledrive", "googlesheets4", "gower", "grf", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "influenceR", "insight", "ipred", "isoband", "jpeg", "keras", "knitr", "later", "lava", "lifecycle", "lme4", "lmtest", "lubridate", "magrittr", "mapproj", "maps", "maptools", "Matching", "MatchIt", "matrixStats", "memoise", "mice", "mime", "multcomp", "mvtnorm", "nloptr", "openssl", "openxlsx", "optmatch", "packrat", "parameters", "performance", "pillar", "pkgbuild", "pkgload", "qualtRics", "quantreg", "R6", "randomForest", "rbibutils", "rcmdcheck", "RcppArmadillo", "RcppParallel", "Rdpack", "readr", "recipes", "remotes", "reprex", "rio", "rlang", "rmarkdown", "rootSolve", "rpart", "rsconnect", "rstan", "rvest", "sessioninfo", "shiny", "shinyjs", "sp", "stringi", "survey", "tensorflow", "testthat", "tibble", "tidyr", "tinytex", "TMB", "usethis", "utf8", "uuid", "V8", "vcd", "viridis", "visNetwork", "waldo", "xfun", "xml2", "yaml"))
install.packages(c("backports", "bayestestR", "BH", "blob", "brew", "brio", "broom", "broom.mixed", "broomExtra", "bslib", "cachem", "car", "carData", "cli", "coin", "colorspace", "colourpicker", "conquer", "corrplot", "cpp11", "crayon", "credentials", "crosstalk", "DBI", "desc", "DescTools", "devtools", "DiagrammeR", "diffobj", "digest", "dotwhisker", "dplyr", "DT", "dtplyr", "e1071", "estimatr", "Exact", "fansi", "fs", "gargle", "generics", "gert", "ggsignif", "gld", "glue", "googledrive", "googlesheets4", "gower", "grf", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "influenceR", "insight", "ipred", "isoband", "jpeg", "keras", "knitr", "later", "lava", "lifecycle", "lme4", "lmtest", "lubridate", "magrittr", "mapproj", "maps", "maptools", "Matching", "MatchIt", "matrixStats", "memoise", "mice", "mime", "multcomp", "mvtnorm", "nloptr", "openssl", "openxlsx", "optmatch", "packrat", "parameters", "performance", "pillar", "pkgbuild", "pkgload", "qualtRics", "quantreg", "R6", "randomForest", "rbibutils", "rcmdcheck", "RcppArmadillo", "RcppParallel", "Rdpack", "readr", "recipes", "remotes", "reprex", "rio", "rlang", "rmarkdown", "rootSolve", "rpart", "rsconnect", "rstan", "rvest", "sessioninfo", "shiny", "shinyjs", "sp", "stringi", "survey", "tensorflow", "testthat", "tibble", "tidyr", "tinytex", "TMB", "usethis", "utf8", "uuid", "V8", "vcd", "viridis", "visNetwork", "waldo", "xfun", "xml2", "yaml"))
library(devtools)
check()
check_rhub()
check_win_devel()
check_win_release()
check()
release()
